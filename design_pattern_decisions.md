Design Pattern Decisions

I have made a few design pattern decisions in developing this application that I touched upon in the readme and this document will seek to highlight all of them. First, with regards to state variables I elected to maintain a TCR list of the incumbent addresses in addition to a list with the string name of each incumbent because it allowed me to pass the address list to other functions for processing purposes (Solidity cannot support passing a list of strings as a argument to a function) and saved instances of the TCRHelper and PLCRVoting contract within the TCR contract for easy access. Secondly, I implemented a circuit breaker in both the TCR and PLCRVoting contracts so as to allow the owner of the contracts to halt all functionality in the case of an attack. The owner must simply call the freezeAllMotorFunctions function in each contract in order to do so. Thirdly, I implemented a state machine enum called Stages in the TCR contract that restricts certain functions to be callable at particular points in the program. Similarly, in the PLCRVoting contract there are require statements before all the Voting Interface functions that ensure the functions can only be called at a specified stage in the voting process. These measures help to mitigate unforeseen usage of the contract. Next, I invoked a pull (rather than push) pattern of depositing and withdrawing ether from each contract by maintaining balances in a mapping state variable and update it according to the user's deposit/withdraw action. This, in tandem with a cognizant effort to reorder withdrawal and record-keeping logic so that user's balances are erased from mappings before tokens are returned to them, address reentrancy, cross-function race condition, and denial of service with revert threats. Furthermore, I included a modifyParameters function that allows the owner to tweak the parameters of the TCR (hopefully) upon request from the public in order to make the application more attractive to curators. Lastly, I implemented a commit-reveal scheme that obfuscates curator's votes until the ballot is closed so that a malicious actor couldn't read the blockchain and determine which way curators are tending to vote to rig the ballot.
